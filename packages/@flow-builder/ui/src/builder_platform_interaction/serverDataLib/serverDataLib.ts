import { readonly } from 'lwc';

export const SERVER_ACTION_TYPE = {
    GET_FLOW: 'getFlow',
    SAVE_FLOW: 'saveFlow',
    GET_RULES: 'getRules',
    GET_SUPPORTED_ELEMENTS: 'getElements',
    GET_SUPPORTED_SCREEN_FIELD_TYPES: 'getScreenFieldTypes',
    GET_INVOCABLE_ACTIONS: 'getInvocableActions',
    GET_STANDARD_INVOCABLE_ACTIONS: 'getStandardInvocableActions',
    GET_DYNAMIC_INVOCABLE_ACTIONS: 'getDynamicInvocableActions',
    GET_APEX_PLUGINS: 'getApexPlugins',
    GET_SUBFLOWS: 'getSubflows',
    GET_INVOCABLE_ACTION_PARAMETERS: 'getInvocableActionParameters',
    GET_APEX_PLUGIN_PARAMETERS: 'getApexPluginParameters',
    GET_ENTITIES: 'getEntities',
    GET_ENTITY: 'getEntity',
    GET_ENTITY_FIELDS: 'getEntityFields',
    GET_RELATED_RECORDS_FIELDS_FOR_ENTITY: 'getRelatedRecordFieldsForEntity',
    GET_ALL_GLOBAL_VARIABLES: 'getAllGlobalVariables',
    GET_ALL_GLOBAL_VARIABLES_EXCLUDE_LABELS: 'getAllGlobalVariablesExcludeLabels',
    GET_ALL_GLOBAL_VARIABLES_ONLY_LABELS: 'getAllGlobalVariablesOnlyLabels',
    GET_SYSTEM_VARIABLES: 'getSystemVariables',
    GET_PROCESS_TYPES: 'getProcessTypes',
    GET_RUN_IN_MODES: 'getRunInModes',
    GET_HEADER_URLS: 'getHeaderUrls',
    GET_RESOURCE_TYPES: 'getResourceTypes',
    GET_FLOW_EXTENSIONS: 'getFlowExtensions',
    GET_FLOW_EXTENSION_PARAMS: 'getFlowExtensionParams',
    GET_FLOW_EXTENSION_LIST_PARAMS: 'getFlowExtensionListParams',
    GET_CONTEXT: 'getContext',
    GET_OPERATORS: 'getOperators',
    GET_FLOW_INPUT_OUTPUT_VARIABLES: 'getFlowInputOutputVariables',
    GET_FLOW_ACTIVE_OR_LATEST_RUN_IN_MODE: 'getFlowActiveOrLatestRunInMode',
    GET_EVENT_TYPES: 'getEventTypes',
    GET_EVENT_TYPE: 'getEventType',
    GET_EVENT_TYPE_PARAMETERS: 'getParametersForEventType',
    GET_PERIPHERAL_DATA_FOR_PROPERTY_EDITOR: 'getPeripheralDataForPropertyEditor',
    GET_APEX_TYPES: 'getApexTypes',
    GET_TEMPLATES: 'getTemplates',
    GET_TEMPLATE_DATA: 'getTemplateData',
    GET_PROCESS_TYPE_FEATURES: 'getSupportedFeaturesList',
    TOGGLE_FLOW_STATUS: 'toggleFlowStatus',
    GET_INVOCABLE_ACTION_DETAILS: 'getInvocableActionDetails',
    GET_WORKFLOW_ENABLED_ENTITIES: 'getWorkflowEnabledEntities',
    GET_FLOW_EXTENSION_DETAILS: 'getFlowExtensionDetails',
    GET_FLOW_ENTRIES: 'getFlowEntries',
    GET_TRIGGER_TYPE_INFO: 'getTriggerTypeInfo',
    GET_PALETTE: 'getPalette',
    GET_RECORD_DEV_NAME_BY_ID: 'getRecordDevNameById',
    GET_RECORD_ID_BY_DEV_NAME: 'getRecordIdByDevName',
    GET_VERSIONING_INFO: 'getVersioningInfo',
    RUN_DEBUG: 'runDebug',
    GET_TEST_DETAIL_FROM_DEBUG_RUN: 'retrieveTestDetailFromDebugRun',
    RETRIEVE_INTERVIEW_HISTORY: 'retrieveInterviewHistory',
    GET_AUTOMATIC_FIELD_OBJECT_MANAGER_URLS: 'getObjectManagerUrls',
    RESUME_DEBUG_INTERVIEW: 'resumeDebugInterview',
    GET_AUTOMATIC_FIELD_URLS: 'getAutomaticFieldUrls',
    GET_AUTO_GENERATED_REQUIRED_VARIABLES: 'getAutoGeneratedRequiredVariables',
    GET_OVERRIDABLE_FLOWS: 'getOverridableFlows',
    GET_FLOW_TESTS_AND_RESULTS: 'getFlowTestsAndResults',
    GET_FORMULA_FUNCTIONS: 'getFormulaFunctions',
    GET_FORMULA_OPERATORS: 'getFormulaOperators',
    DELETE_FLOW_TEST: 'deleteFlowTest',
    SAVE_FLOW_TEST: 'storeFlowTest',
    RUN_FLOW_TESTS: 'runFlowTests',
    GET_FLOW_TEST: 'retrieveFlowTest',
    VALIDATE_FORMULA: 'validateFormulaSyntax',
    GET_FLOW_IDS: 'getFlowIds',
    SET_USER_PREFERENCES: 'setUserPreferences'
};

const actionConfig = {
    [SERVER_ACTION_TYPE.GET_FLOW]: 'c.retrieveFlow',
    [SERVER_ACTION_TYPE.SAVE_FLOW]: 'c.saveFlow',
    [SERVER_ACTION_TYPE.GET_RULES]: 'c.retrieveAllRules',
    [SERVER_ACTION_TYPE.GET_SUPPORTED_ELEMENTS]: 'c.getSupportedElements',
    [SERVER_ACTION_TYPE.GET_SUPPORTED_SCREEN_FIELD_TYPES]: 'c.getSupportedScreenFields',
    [SERVER_ACTION_TYPE.GET_INVOCABLE_ACTIONS]: 'c.getAllInvocableActionsForType',
    [SERVER_ACTION_TYPE.GET_STANDARD_INVOCABLE_ACTIONS]: 'c.getStandardInvocableActionsForType',
    [SERVER_ACTION_TYPE.GET_DYNAMIC_INVOCABLE_ACTIONS]: 'c.getDynamicInvocableActionsForType',
    [SERVER_ACTION_TYPE.GET_APEX_PLUGINS]: 'c.getApexPlugins',
    [SERVER_ACTION_TYPE.GET_SUBFLOWS]: 'c.getSubflows',
    [SERVER_ACTION_TYPE.GET_INVOCABLE_ACTION_PARAMETERS]: 'c.getInvocableActionParameters',
    [SERVER_ACTION_TYPE.GET_APEX_PLUGIN_PARAMETERS]: 'c.getApexPluginParameters',
    [SERVER_ACTION_TYPE.GET_ENTITIES]: 'c.getEntities',
    [SERVER_ACTION_TYPE.GET_ENTITY]: 'c.getEntity',
    [SERVER_ACTION_TYPE.GET_ENTITY_FIELDS]: 'c.getFieldsForEntity',
    [SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES]: 'c.getAllGlobalVariables',
    [SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES_EXCLUDE_LABELS]: 'c.getAllButLabelGlobalVariables',
    [SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES_ONLY_LABELS]: 'c.getLabelGlobalVariables',

    [SERVER_ACTION_TYPE.GET_SYSTEM_VARIABLES]: 'c.getSystemVariables',
    [SERVER_ACTION_TYPE.GET_PROCESS_TYPES]: 'c.getProcessTypes',
    [SERVER_ACTION_TYPE.GET_RUN_IN_MODES]: 'c.getRunInModes',
    [SERVER_ACTION_TYPE.GET_HEADER_URLS]: 'c.retrieveHeaderUrls',
    [SERVER_ACTION_TYPE.GET_RESOURCE_TYPES]: 'c.getResourceTypes',
    [SERVER_ACTION_TYPE.GET_FLOW_EXTENSIONS]: 'c.getFlowExtensions',
    [SERVER_ACTION_TYPE.GET_FLOW_EXTENSION_PARAMS]: 'c.getFlowExtensionParams',
    [SERVER_ACTION_TYPE.GET_FLOW_EXTENSION_LIST_PARAMS]: 'c.getFlowExtensionListParams',
    [SERVER_ACTION_TYPE.SET_USER_PREFERENCES]: 'c.setUserPreferences',
    [SERVER_ACTION_TYPE.GET_CONTEXT]: 'c.getContext',
    [SERVER_ACTION_TYPE.GET_OPERATORS]: 'c.getOperators',
    [SERVER_ACTION_TYPE.GET_FLOW_INPUT_OUTPUT_VARIABLES]: 'c.getFlowInputOutputVariables',
    [SERVER_ACTION_TYPE.GET_FLOW_ACTIVE_OR_LATEST_RUN_IN_MODE]: 'c.getFlowActiveOrLatestRunInMode',
    [SERVER_ACTION_TYPE.GET_EVENT_TYPES]: 'c.getEventTypes',
    [SERVER_ACTION_TYPE.GET_EVENT_TYPE]: 'c.getEventType',
    [SERVER_ACTION_TYPE.GET_EVENT_TYPE_PARAMETERS]: 'c.getParametersForEventType',
    [SERVER_ACTION_TYPE.GET_APEX_TYPES]: 'c.getApexTypes',
    [SERVER_ACTION_TYPE.GET_TEMPLATES]: 'c.getTemplates',
    [SERVER_ACTION_TYPE.GET_TEMPLATE_DATA]: 'c.getTemplateData',
    [SERVER_ACTION_TYPE.GET_PROCESS_TYPE_FEATURES]: 'c.getSupportedFeaturesList',
    [SERVER_ACTION_TYPE.GET_RECORD_DEV_NAME_BY_ID]: 'c.getRecordDevNameById',
    [SERVER_ACTION_TYPE.GET_RECORD_ID_BY_DEV_NAME]: 'c.getRecordIdByDevName',
    [SERVER_ACTION_TYPE.TOGGLE_FLOW_STATUS]: 'c.toggleFlowStatus',
    [SERVER_ACTION_TYPE.GET_INVOCABLE_ACTION_DETAILS]: 'c.getInvocableActionDetails',
    [SERVER_ACTION_TYPE.GET_WORKFLOW_ENABLED_ENTITIES]: 'c.getWorkflowEnabledEntities',
    [SERVER_ACTION_TYPE.GET_FLOW_EXTENSION_DETAILS]: 'c.getFlowExtensionDetails',
    [SERVER_ACTION_TYPE.GET_FLOW_ENTRIES]: 'c.getFlowEntries',
    [SERVER_ACTION_TYPE.GET_TRIGGER_TYPE_INFO]: 'c.getTriggerTypeInfo',
    [SERVER_ACTION_TYPE.GET_PALETTE]: 'c.getPalette',
    [SERVER_ACTION_TYPE.GET_VERSIONING_INFO]: 'c.getVersioningInfo',
    [SERVER_ACTION_TYPE.RUN_DEBUG]: 'c.runDebugInterview',
    [SERVER_ACTION_TYPE.GET_TEST_DETAIL_FROM_DEBUG_RUN]: 'c.retrieveTestDetailFromDebugRun',
    [SERVER_ACTION_TYPE.RETRIEVE_INTERVIEW_HISTORY]: 'c.retrieveInterviewHistory',
    [SERVER_ACTION_TYPE.GET_AUTOMATIC_FIELD_OBJECT_MANAGER_URLS]: 'c.getObjectManagerUrls',
    [SERVER_ACTION_TYPE.RESUME_DEBUG_INTERVIEW]: 'c.resumeDebugInterview',
    [SERVER_ACTION_TYPE.GET_AUTOMATIC_FIELD_URLS]: 'c.getAutomaticFieldUrls',
    [SERVER_ACTION_TYPE.GET_AUTO_GENERATED_REQUIRED_VARIABLES]: 'c.getAutoGeneratedRequiredVariables',
    [SERVER_ACTION_TYPE.GET_OVERRIDABLE_FLOWS]: 'c.getOverridableFlows',
    [SERVER_ACTION_TYPE.GET_FLOW_TESTS_AND_RESULTS]: 'c.getFlowTestsAndResults',
    [SERVER_ACTION_TYPE.GET_FORMULA_FUNCTIONS]: 'c.getFormulaFunctions',
    [SERVER_ACTION_TYPE.GET_FORMULA_OPERATORS]: 'c.getFormulaOperators',
    [SERVER_ACTION_TYPE.DELETE_FLOW_TEST]: 'c.deleteFlowTest',
    [SERVER_ACTION_TYPE.SAVE_FLOW_TEST]: 'c.storeFlowTest',
    [SERVER_ACTION_TYPE.RUN_FLOW_TESTS]: 'c.runFlowTests',
    [SERVER_ACTION_TYPE.GET_FLOW_TEST]: 'c.retrieveFlowTest',
    [SERVER_ACTION_TYPE.VALIDATE_FORMULA]: 'c.validateFormulaSyntax',
    [SERVER_ACTION_TYPE.GET_FLOW_IDS]: 'c.getFlowIds',
    [SERVER_ACTION_TYPE.GET_RELATED_RECORDS_FIELDS_FOR_ENTITY]: 'c.getRelatedRecordFieldsForEntity'
};

let auraFetch;
let auraCallback;

/**
 * Set the generic function to get server data
 *
 * @param {Function} fn aura fetch function
 */
export function setAuraFetch(fn?) {
    auraFetch = fn;
}

/**
 * @param value
 */
export function setAuraGetCallback(value) {
    auraCallback = value;
}

/**
 * Provides the aura wrapper function, which ensures that a function supplied to the wrapper
 * is executed under aura context. This is used for making sure the aura can bundle
 * together multiple foreground calls.
 *
 * @param fn
 */
export function getAuraCallback(fn) {
    return auraCallback(fn);
}

/**
 * Makes the call to get server data and executes callback if component is still connected.
 *
 * @param {string} serverActionType - type of action to be executed
 * @param {Function} callback - function to be executed after getting response from server
 * @param {Object} params - any parameters to make server call
 * @param {Object} storable
 * @param {boolean} storable.background
 * @param {boolean} storable.storable - set to true if results need to be cached, Background set to true if request needs to be run as background action
 * @param {boolean} storable.disableErrorModal
 * @param storable.messageForErrorModal
 * @returns {Function} setComponentDisconnected - this should be called in disconnected callback of a component
 */
export function fetch(
    serverActionType,
    callback,
    params,
    { background = false, storable = false, disableErrorModal = false, messageForErrorModal = undefined } = {}
) {
    let executeCallback = true;

    /**
     *
     */
    function shouldExecuteCallback() {
        return executeCallback;
    }

    /**
     *
     */
    function stopCallbackExecution() {
        executeCallback = false;
    }

    if (actionConfig[serverActionType] && auraFetch) {
        auraFetch(
            actionConfig[serverActionType],
            shouldExecuteCallback,
            callback,
            params,
            background,
            storable,
            disableErrorModal,
            messageForErrorModal
        );
    }
    return stopCallbackExecution;
}

const KEY_PROVIDER = {
    [SERVER_ACTION_TYPE.GET_APEX_PLUGINS]: () => 'default',
    [SERVER_ACTION_TYPE.GET_RULES]: (params) =>
        `${params.flowProcessType}-${params.flowTriggerType}-${params.recordTriggerType}`,
    [SERVER_ACTION_TYPE.GET_OPERATORS]: (params) =>
        `${params.flowProcessType}-${params.flowTriggerType}-${params.recordTriggerType}`,
    [SERVER_ACTION_TYPE.GET_ENTITIES]: () => SERVER_ACTION_TYPE.GET_ENTITIES,
    [SERVER_ACTION_TYPE.GET_ENTITY]: () => (params) => `${params.entityApiName}`,
    [SERVER_ACTION_TYPE.GET_RESOURCE_TYPES]: (params) => params.flowProcessType,
    [SERVER_ACTION_TYPE.GET_EVENT_TYPES]: () => (params) => params.eventType,
    [SERVER_ACTION_TYPE.GET_EVENT_TYPE]: (params) => params.eventTypeApiName,
    [SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES]: () => SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES,
    [SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES_EXCLUDE_LABELS]: () =>
        SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES_EXCLUDE_LABELS,
    [SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES_ONLY_LABELS]: () =>
        SERVER_ACTION_TYPE.GET_ALL_GLOBAL_VARIABLES_ONLY_LABELS,
    [SERVER_ACTION_TYPE.GET_SYSTEM_VARIABLES]: () => SERVER_ACTION_TYPE.GET_SYSTEM_VARIABLES,
    [SERVER_ACTION_TYPE.GET_HEADER_URLS]: () => SERVER_ACTION_TYPE.GET_HEADER_URLS,
    [SERVER_ACTION_TYPE.GET_PROCESS_TYPES]: (params) => `${params.builderType}`,
    [SERVER_ACTION_TYPE.GET_RUN_IN_MODES]: () => SERVER_ACTION_TYPE.GET_RUN_IN_MODES,
    [SERVER_ACTION_TYPE.GET_RECORD_ID_BY_DEV_NAME]: (params) => `${params.entity}-${params.devName}`,
    [SERVER_ACTION_TYPE.GET_RECORD_DEV_NAME_BY_ID]: (params) => `${params.entity}-${params.recordId}`,
    [SERVER_ACTION_TYPE.GET_SUBFLOWS]: (params) => params.flowProcessType,
    [SERVER_ACTION_TYPE.GET_INVOCABLE_ACTIONS]: (params) => `${params.flowProcessType}-${params.flowTriggerType}`,
    [SERVER_ACTION_TYPE.GET_STANDARD_INVOCABLE_ACTIONS]: (params) =>
        `${params.flowProcessType}-${params.flowTriggerType}`,
    [SERVER_ACTION_TYPE.GET_DYNAMIC_INVOCABLE_ACTIONS]: (params) =>
        `${params.flowProcessType}-${params.flowTriggerType}`,
    [SERVER_ACTION_TYPE.GET_SUPPORTED_SCREEN_FIELD_TYPES]: (params) =>
        `${params.flowProcessType}-${params.flowEnvironmentKey}`,
    [SERVER_ACTION_TYPE.GET_INVOCABLE_ACTION_PARAMETERS]: (params) => `${params.actionName}-${params.actionType}`,
    [SERVER_ACTION_TYPE.GET_APEX_PLUGIN_PARAMETERS]: (params) => `${params.apexClass}`,
    [SERVER_ACTION_TYPE.GET_ENTITY_FIELDS]: (params) => params.entityApiName,
    [SERVER_ACTION_TYPE.GET_RELATED_RECORDS_FIELDS_FOR_ENTITY]: (params) => params.entityApiName,
    [SERVER_ACTION_TYPE.GET_FLOW_INPUT_OUTPUT_VARIABLES]: (params) => params.flowName,
    [SERVER_ACTION_TYPE.GET_FLOW_ACTIVE_OR_LATEST_RUN_IN_MODE]: (params) => params.flowName,
    [SERVER_ACTION_TYPE.GET_APEX_TYPES]: (params) => params.flowProcessType,
    [SERVER_ACTION_TYPE.GET_TEMPLATES]: (params) => params.processTypes,
    [SERVER_ACTION_TYPE.GET_TEMPLATE_DATA]: (params) => params.versionIdOrEnum,
    [SERVER_ACTION_TYPE.GET_PROCESS_TYPE_FEATURES]: (params) => params.flowProcessType,
    [SERVER_ACTION_TYPE.GET_INVOCABLE_ACTION_DETAILS]: (params) => `${params.actionName}-${params.actionType}`,
    [SERVER_ACTION_TYPE.GET_WORKFLOW_ENABLED_ENTITIES]: () => SERVER_ACTION_TYPE.GET_WORKFLOW_ENABLED_ENTITIES,
    [SERVER_ACTION_TYPE.GET_FLOW_ENTRIES]: (params) => `${params.builderType}`,
    [SERVER_ACTION_TYPE.GET_TRIGGER_TYPE_INFO]: (params) => `${params.triggerType}`,
    [SERVER_ACTION_TYPE.GET_PALETTE]: (params) => `${params.flowProcessType}-${params.flowTriggerType}`,
    [SERVER_ACTION_TYPE.GET_VERSIONING_INFO]: (params) => params.builderType,
    [SERVER_ACTION_TYPE.GET_AUTOMATIC_FIELD_OBJECT_MANAGER_URLS]: () =>
        SERVER_ACTION_TYPE.GET_AUTOMATIC_FIELD_OBJECT_MANAGER_URLS,
    [SERVER_ACTION_TYPE.GET_AUTOMATIC_FIELD_URLS]: () => SERVER_ACTION_TYPE.GET_AUTOMATIC_FIELD_URLS,
    [SERVER_ACTION_TYPE.GET_AUTO_GENERATED_REQUIRED_VARIABLES]: (params) => params.flowProcessType,
    [SERVER_ACTION_TYPE.GET_OVERRIDABLE_FLOWS]: (params) =>
        `${params.flowProcessType}-${params.flowProcessType}-${params.isTemplate}`,
    [SERVER_ACTION_TYPE.GET_FLOW_EXTENSIONS]: (params) => `${params.flowProcessType}-${params.flowEnvironmentKey}`,
    [SERVER_ACTION_TYPE.GET_FLOW_TESTS_AND_RESULTS]: (params) =>
        `${params.flowDefinitionId}-${params.flowVersionid}-${params.offset}-${params.limit}`,
    [SERVER_ACTION_TYPE.GET_FORMULA_FUNCTIONS]: (params) =>
        `${params.flowProcessType}-${params.flowTriggerType}-${params.recordTriggerType}`,
    [SERVER_ACTION_TYPE.GET_FORMULA_OPERATORS]: (params) => `${params.flowProcessType}-${params.flowTriggerType}`,
    [SERVER_ACTION_TYPE.GET_FLOW_IDS]: (params) => params.flowNameList
};

const fetchOnceCache = {};

/**
 * Makes the call to get server data. Ensure call is only made once if successful.
 *
 * @param {string} serverActionType - type of action to be executed
 * @param {Object} params - any parameters to make server call
 * @param {Object} args
 * @param {boolean} args.background - background need to be set to true if request needs to be run as a background action
 * @param {boolean} args.disableErrorModal - disableErrorModal need to be set to true to disable the default error modal panel
 * @param {(string|undefined)} args.messageForErrorModal - the message to use instead of the default error message
 * @returns {Promise} Promise object represents the return value from the server
 *         side action
 */
export function fetchOnce(
    serverActionType,
    params = {},
    { background = false, disableErrorModal = false, messageForErrorModal = undefined } = {}
) {
    const keyProvider = KEY_PROVIDER[serverActionType];
    if (!keyProvider) {
        throw new Error(`No keyProvider configured for ${serverActionType}`);
    }
    const key = keyProvider(params);
    let serverActionTypeCache = fetchOnceCache[serverActionType];
    if (serverActionTypeCache) {
        // we retry fetching if rejected
        if (serverActionTypeCache[key] && !serverActionTypeCache[key].isRejected()) {
            return serverActionTypeCache[key];
        }
    } else {
        serverActionTypeCache = {};
        fetchOnceCache[serverActionType] = serverActionTypeCache;
    }
    // we can use a promise because we don't use a storable action
    let rejected = false;
    let pending = true;
    serverActionTypeCache[key] = new Promise((resolve, reject) => {
        fetch(
            serverActionType,
            ({ data, error }) => {
                pending = false;
                if (error) {
                    rejected = true;
                    const errorMessage =
                        Array.isArray(error) && error.length === 1 && error[0].message ? error[0].message : error;
                    const newError = new Error(errorMessage);
                    if (typeof error === 'object') {
                        // TODO: please fix
                        // @ts-ignore
                        newError.cause = error;
                    }
                    reject(newError);
                } else {
                    resolve(readonly(data));
                }
            },
            params,
            {
                background,
                storable: false,
                disableErrorModal,
                messageForErrorModal
            }
        );
    });
    serverActionTypeCache[key].isRejected = () => !pending && rejected;
    serverActionTypeCache[key].isFulfilled = () => !pending && !rejected;
    serverActionTypeCache[key].isPending = () => pending;
    return serverActionTypeCache[key];
}

/**
 *
 * Fetch call that returns a Promise
 *
 * @param serverActionType  the name of the server action
 * @param params parameters for the server action call
 * @param optionalParams
 * @param optionalParams.background need to be set to true if request needs to be run as a background action
 * @param optionalParams.disableErrorModal need to be set to true to disable the default error modal panel
 * @param optionalParams.messageForErrorModal the message to use instead of the default error message
 * @returns {Promise} promise for handling the fetch call
 */
export function fetchPromise(
    serverActionType: string,
    params: Object = {},
    { background = false, disableErrorModal = false, messageForErrorModal = undefined } = {}
) {
    return new Promise((resolve, reject) => {
        fetch(
            serverActionType,
            ({ data, error }) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(data);
                }
            },
            params,
            {
                background,
                disableErrorModal,
                messageForErrorModal
            }
        );
    });
}

/**
 * @param serverActionType
 * @param params
 */
export function isAlreadyFetched(serverActionType, params = {}) {
    const keyProvider = KEY_PROVIDER[serverActionType];
    if (!keyProvider) {
        throw new Error(`No keyProvider configured for ${serverActionType}`);
    }
    const key = keyProvider(params);
    const serverActionTypeCache = fetchOnceCache[serverActionType];
    if (!serverActionTypeCache) {
        return false;
    }
    const promise = serverActionTypeCache[key];
    if (!promise) {
        return false;
    }
    return promise.isFulfilled();
}

/**
 *
 */
export function resetFetchOnceCache() {
    for (const prop in fetchOnceCache) {
        if (fetchOnceCache.hasOwnProperty(prop)) {
            delete fetchOnceCache[prop];
        }
    }
}
